"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUrls = void 0;
const utils_1 = require("../../libs/utils");
const option_maps_1 = require("../../options/option-maps");
const path = __importStar(require("path"));
const typedoc_1 = require("typedoc");
/**
 * Map the models of the given project to the desired output files.
 * Based on TypeDoc DefaultTheme.getUrls()
 *
 * @param project  The project whose urls should be generated.
 */
function buildUrls(theme, project) {
    const options = theme.application.options;
    const packagesMeta = theme.application.renderer
        .packagesMeta;
    const urls = [];
    const anchors = {};
    const flattenOutputFiles = options.getValue('flattenOutputFiles');
    const fileExtension = options.getValue('fileExtension');
    const ignoreScopes = options.getValue('excludeScopesInPaths');
    const entryFileName = (0, utils_1.getFileNameWithExtension)(options.getValue('entryFileName'), fileExtension);
    const isPackages = options.getValue('entryPointStrategy') === typedoc_1.EntryPointStrategy.Packages;
    buildEntryUrls();
    if (isPackages) {
        if (Object.keys(packagesMeta)?.length === 1) {
            buildUrlsFromProject(project);
        }
        else {
            project.children?.forEach((projectChild) => {
                buildUrlsFromPackage(projectChild);
            });
        }
    }
    else {
        buildUrlsFromProject(project);
    }
    return flattenOutputFiles ? flattenFiles(urls) : urls;
    function buildEntryUrls() {
        const preserveReadme = Boolean(project.readme) && !options.getValue('mergeReadme');
        const isModulesOnly = project.children?.every((child) => child.kind === typedoc_1.ReflectionKind.Module);
        const useEntryModule = project?.groups &&
            Boolean(project?.groups[0]?.children.find((child) => child.name === options.getValue('entryModule'))) &&
            isModulesOnly;
        const indexFilename = getIndexFileName(project, isPackages);
        project.url = preserveReadme
            ? indexFilename
            : useEntryModule
                ? indexFilename
                : entryFileName;
        if (preserveReadme) {
            urls.push({
                url: useEntryModule
                    ? (0, utils_1.getFileNameWithExtension)('readme_', fileExtension)
                    : entryFileName,
                model: project,
                template: theme.readmeTemplate,
            });
            if (!useEntryModule) {
                urls.push({
                    url: indexFilename,
                    model: project,
                    template: theme.projectTemplate,
                });
            }
        }
        else {
            if (!useEntryModule) {
                urls.push({
                    url: entryFileName,
                    model: project,
                    template: theme.projectTemplate,
                });
            }
        }
    }
    function buildUrlsFromProject(project, parentUrl, outputFileStrategy, entryModule, entryFileName) {
        project.groups?.forEach((projectGroup) => {
            projectGroup.children?.forEach((projectGroupChild) => {
                buildUrlsFromGroup(projectGroupChild, {
                    ...(parentUrl && { parentUrl }),
                    ...(outputFileStrategy && { outputFileStrategy }),
                    ...(entryModule && { entryModule }),
                    ...(entryFileName && { entryFileName }),
                });
            });
        });
    }
    function buildUrlsFromPackage(projectChild) {
        const preservePackageReadme = Boolean(projectChild.readme) && !options.getValue('mergeReadme');
        const packagesIndex = getIndexFileName(projectChild);
        const packageOptions = packagesMeta[projectChild.name]?.options;
        const outputFileStrategy = packageOptions.isSet('outputFileStrategy')
            ? packageOptions.getValue('outputFileStrategy')
            : options.getValue('outputFileStrategy');
        const entryModule = packageOptions.isSet('entryModule')
            ? packageOptions.getValue('entryModule')
            : options.getValue('entryModule');
        const packageEntryFileName = packageOptions.isSet('entryFileName')
            ? packageOptions.getValue('entryFileName')
            : options.getValue('entryFileName');
        let fullEntryFileName = (0, utils_1.getFileNameWithExtension)(path.join(projectChild.name, packageEntryFileName), fileExtension);
        let fullIndexFileName = (0, utils_1.getFileNameWithExtension)(path.join(projectChild.name, packagesIndex), fileExtension);
        if (ignoreScopes) {
            fullEntryFileName = (0, utils_1.removeFirstScopedDirectory)(fullEntryFileName);
            fullIndexFileName = (0, utils_1.removeFirstScopedDirectory)(fullIndexFileName);
        }
        const indexFileName = preservePackageReadme
            ? fullIndexFileName
            : fullEntryFileName;
        const isModulesOnly = projectChild.children?.every((child) => child.kind === typedoc_1.ReflectionKind.Module);
        const useEntryModule = projectChild?.groups &&
            Boolean(projectChild?.groups[0]?.children.find((child) => child.name === entryModule)) &&
            isModulesOnly;
        if (preservePackageReadme) {
            urls.push({
                url: useEntryModule
                    ? `${path.dirname(indexFileName)}/${(0, utils_1.getFileNameWithExtension)('readme_', fileExtension)}`
                    : path.join(path.dirname(indexFileName), (0, utils_1.getFileNameWithExtension)(packageEntryFileName, fileExtension)),
                model: projectChild,
                template: theme.readmeTemplate,
            });
            if (!useEntryModule) {
                urls.push({
                    url: indexFileName,
                    model: projectChild,
                    template: theme.projectTemplate,
                });
            }
        }
        else {
            if (!useEntryModule) {
                urls.push({
                    url: indexFileName,
                    model: projectChild,
                    template: theme.projectTemplate,
                });
            }
        }
        projectChild.url = indexFileName;
        const parentUrl = indexFileName.split(path.sep)?.length > 1
            ? indexFileName
            : `${projectChild.name}/${indexFileName}`;
        buildUrlsFromProject(projectChild, parentUrl, outputFileStrategy, entryModule, fullEntryFileName);
    }
    function buildUrlsFromGroup(reflection, urlOptions) {
        const mapping = theme.getTemplateMapping(reflection.kind, urlOptions.outputFileStrategy);
        if (mapping) {
            const directory = urlOptions.directory || mapping.directory;
            const urlPath = getUrlPath(reflection, {
                ...urlOptions,
                directory,
            });
            let url = getUrl(reflection, urlPath, urlOptions);
            if (ignoreScopes) {
                url = (0, utils_1.removeFirstScopedDirectory)(url);
            }
            const duplicateUrls = urls.filter((urlMapping) => urlMapping.url.toLowerCase().replace(/-\d+$/, '') ===
                url.toLowerCase());
            if (duplicateUrls.length > 0) {
                const urlParts = url.split('.');
                urlParts[urlParts.length - 2] += `-${duplicateUrls.length}`;
                url = urlParts.join('.');
            }
            urls.push({
                url: url,
                model: reflection,
                template: mapping.template,
            });
            reflection.url = url;
            reflection.hasOwnDocument = true;
            reflection.groups?.forEach((group) => {
                group.children.forEach((groupChild) => {
                    const mapping = theme.getTemplateMapping(groupChild.kind, urlOptions.outputFileStrategy);
                    buildUrlsFromGroup(groupChild, {
                        parentUrl: urlPath,
                        directory: mapping?.directory || null,
                        outputFileStrategy: urlOptions.outputFileStrategy,
                    });
                });
            });
        }
        else if (reflection.parent) {
            applyAnchorUrl(reflection, reflection.parent);
        }
    }
    function getUrl(reflection, urlPath, urlOptions) {
        const entryModule = urlOptions.entryModule || options.getValue('entryModule');
        const entryName = urlOptions.entryFileName || entryFileName;
        if (reflection.name === entryModule) {
            return entryName;
        }
        if (options.getValue('outputFileStrategy') === option_maps_1.OutputFileStrategy.Modules &&
            reflection.name === 'index' &&
            path.parse(entryName).name === 'index') {
            return urlPath.replace((0, utils_1.getFileNameWithExtension)('index', fileExtension), (0, utils_1.getFileNameWithExtension)('module_index', fileExtension));
        }
        return urlPath;
    }
    function getUrlPath(reflection, urlOption) {
        const alias = reflection.name
            .replace(/^_+|_+$/g, '')
            .replace(/</, '-')
            .replace(/>/, '-');
        const parentDir = urlOption.parentUrl
            ? path.dirname(urlOption.parentUrl)
            : null;
        const dir = () => {
            if (reflection.kind === typedoc_1.ReflectionKind.Namespace) {
                return `${urlOption.directory}/${alias}`;
            }
            if (reflection.kind === typedoc_1.ReflectionKind.Module) {
                return alias;
            }
            return urlOption.directory
                ? urlOption.directory
                : `${(0, utils_1.slugifyUrl)(typedoc_1.ReflectionKind.singularString(reflection.kind))}.${alias}`;
        };
        const filename = () => {
            if ([typedoc_1.ReflectionKind.Module, typedoc_1.ReflectionKind.Namespace].includes(reflection.kind) &&
                options.getValue('outputFileStrategy') === option_maps_1.OutputFileStrategy.Modules &&
                !childrenIncludeNamespaces(reflection)) {
                return null;
            }
            if ([typedoc_1.ReflectionKind.Module, typedoc_1.ReflectionKind.Namespace].includes(reflection.kind)) {
                return path.parse(entryFileName).name;
            }
            return alias;
        };
        return (0, utils_1.getFileNameWithExtension)([parentDir, dir(), filename()].filter((part) => Boolean(part)).join('/'), fileExtension);
    }
    function applyAnchorUrl(reflection, container) {
        if (container.url) {
            if (reflection.kind !== typedoc_1.ReflectionKind.TypeLiteral) {
                const anchorPrefix = options.getValue('anchorPrefix');
                const anchorId = getAnchorId(reflection);
                if (anchorId) {
                    if (!anchors[container.url]) {
                        anchors[container.url] = [];
                    }
                    anchors[container.url].push(anchorId);
                    const count = anchors[container.url]?.filter((id) => id === anchorId)?.length;
                    const anchorParts = [anchorId];
                    if (count > 1) {
                        anchorParts.push(`-${count - 1}`);
                    }
                    if (anchorPrefix) {
                        anchorParts.unshift(`${anchorPrefix}`);
                    }
                    reflection.url = container.url + '#' + anchorParts.join('');
                    reflection.anchor = anchorParts.join('');
                    reflection.hasOwnDocument = false;
                }
            }
        }
        if (reflection.parent) {
            reflection.traverse((child) => {
                if (child instanceof typedoc_1.DeclarationReflection) {
                    applyAnchorUrl(child, container);
                }
            });
        }
    }
    function getAnchorId(reflection) {
        const preserveAnchorCasing = options.getValue('preserveAnchorCasing');
        const anchorName = getAnchorName(reflection);
        if (anchorName) {
            return preserveAnchorCasing ? anchorName : anchorName.toLowerCase();
        }
        return null;
    }
    function getAnchorName(reflection) {
        const htmlTableAnchors = options.getValue('useHTMLAnchors');
        if (!htmlTableAnchors) {
            if ((reflection.kind === typedoc_1.ReflectionKind.Property &&
                options.getValue('propertiesFormat') === 'table') ||
                (reflection.kind === typedoc_1.ReflectionKind.EnumMember &&
                    options.getValue('enumMembersFormat') === 'table')) {
                return null;
            }
        }
        if (reflection.kind === typedoc_1.ReflectionKind.Constructor) {
            return 'Constructors';
        }
        const anchorParts = [reflection.name];
        if (reflection.typeParameters?.length) {
            anchorParts.push(reflection.typeParameters
                .map((typeParameter) => typeParameter.name)
                .join(''));
        }
        return anchorParts.join('');
    }
    function childrenIncludeNamespaces(reflection) {
        return reflection.children?.some((child) => child.kind === typedoc_1.ReflectionKind.Namespace);
    }
    function getIndexFileName(reflection, isPackages = false) {
        if (isPackages) {
            return (0, utils_1.getFileNameWithExtension)('packages', fileExtension);
        }
        const isModules = reflection.children?.every((child) => child.kind === typedoc_1.ReflectionKind.Module);
        return isModules
            ? (0, utils_1.getFileNameWithExtension)('modules', fileExtension)
            : (0, utils_1.getFileNameWithExtension)('globals', fileExtension);
    }
    function flattenFiles(urls) {
        const getUrl = (reflection) => {
            const fullname = reflection.getFullName();
            const fullnameParts = fullname.replace(/\//g, '.').split('.');
            if (reflection.kind !== typedoc_1.ReflectionKind.Module) {
                fullnameParts.splice(fullnameParts.length - 1, 0, typedoc_1.ReflectionKind.singularString(reflection.kind).split(' ')[0]);
            }
            const url = `${fullnameParts.join('.')}.md`;
            reflection.url = url;
            return url;
        };
        return urls.map((urlMapping) => {
            if (urlMapping.model.kind === typedoc_1.ReflectionKind.Project) {
                return urlMapping;
            }
            return {
                ...urlMapping,
                url: getUrl(urlMapping.model),
            };
        });
    }
}
exports.buildUrls = buildUrls;
