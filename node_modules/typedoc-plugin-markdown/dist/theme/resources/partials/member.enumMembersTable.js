"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumMembersTable = void 0;
const markdown_1 = require("../../../libs/markdown");
const utils_1 = require("../../../libs/utils");
const typedoc_1 = require("typedoc");
/**
 * Renders enum members as a table.
 *
 * @category Member Partials
 */
function enumMembersTable(model) {
    const comments = model.map((param) => !!param.comment?.hasVisibleComponent());
    const hasComments = comments.some((value) => Boolean(value));
    const headers = [
        this.getText('kind.enumMember.singular'),
        this.getText('label.value'),
    ];
    if (hasComments) {
        headers.push(this.getText('label.description'));
    }
    const rows = model.map((property) => {
        const propertyType = this.helpers.getDeclarationType(property);
        const row = [];
        const nameColumn = [];
        if (this.options.getValue('useHTMLAnchors') && property.anchor) {
            nameColumn.push(`<a id="${property.anchor}" name="${property.anchor}"></a>`);
        }
        nameColumn.push((0, markdown_1.backTicks)(property.name));
        row.push(nameColumn.join(' '));
        if (propertyType) {
            row.push((0, utils_1.removeLineBreaks)(this.partials.someType(propertyType)));
        }
        if (hasComments) {
            const comments = getComments(property);
            if (comments) {
                row.push(this.partials.comment(comments, { isTableColumn: true }));
            }
            else {
                row.push('-');
            }
        }
        return `| ${row.join(' | ')} |\n`;
    });
    const output = `\n| ${headers.join(' | ')} |\n| ${headers
        .map(() => ':------')
        .join(' | ')} |\n${rows.join('')}`;
    return output;
}
exports.enumMembersTable = enumMembersTable;
function getComments(property) {
    if (property.type instanceof typedoc_1.ReflectionType) {
        if (property.type?.declaration?.signatures) {
            return property.type?.declaration.signatures[0].comment;
        }
    }
    if (property.signatures) {
        return property.signatures[0].comment;
    }
    return property.comment;
}
