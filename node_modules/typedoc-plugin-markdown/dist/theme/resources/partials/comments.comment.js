"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.comment = void 0;
const markdown_1 = require("../../../libs/markdown");
const utils_1 = require("../../../libs/utils");
const sanitize_comments_1 = require("../../../libs/utils/sanitize-comments");
/**
 * @category Comment Partials
 */
function comment(model, options = {}) {
    const opts = {
        headingLevel: undefined,
        showSummary: true,
        showTags: true,
        isTableColumn: false,
        ...options,
    };
    const md = [];
    if (opts.showSummary && model.summary?.length > 0) {
        md.push(this.partials.commentParts(model.summary));
    }
    if (opts.showTags && model.blockTags?.length) {
        const blockTags = model.blockTags.reduce((previous, current) => {
            if (current.tag === '@example') {
                const prevExampleTag = previous.find((tag) => ['@example', '@examples'].includes(tag.tag));
                if (prevExampleTag) {
                    return previous.map((prevTag) => {
                        if (prevTag === prevExampleTag) {
                            current.content.unshift({ kind: 'text', text: '\n\n' });
                            return {
                                ...prevTag,
                                tag: '@examples',
                                content: [...prevTag.content, ...current.content],
                            };
                        }
                        return prevTag;
                    });
                }
            }
            return [...previous, current];
        }, []);
        const tags = blockTags
            .filter((tag) => tag.tag !== '@returns')
            .filter((tag) => !opts.isTableColumn ||
            (opts.isTableColumn && tag.tag !== '@defaultValue'))
            .map((tag) => {
            const tagName = tag.tag.substring(1);
            const tagText = (0, utils_1.camelToTitleCase)(tagName);
            const tagMd = [
                opts.headingLevel
                    ? (0, markdown_1.heading)(opts.headingLevel, tagText) + '\n'
                    : (0, markdown_1.bold)(tagText),
            ];
            tagMd.push(this.partials.commentParts(tag.content));
            return tagMd.join('\n');
        });
        md.push(tags.join('\n\n'));
    }
    const output = md.join('\n\n');
    const parsedOutput = this.options.getValue('sanitizeComments')
        ? (0, sanitize_comments_1.sanitizeComments)(output)
        : output;
    return opts.isTableColumn ? (0, utils_1.formatTableColumn)(parsedOutput) : parsedOutput;
}
exports.comment = comment;
