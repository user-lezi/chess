"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.member = void 0;
const markdown_1 = require("../../../libs/markdown");
const utils_1 = require("../../../libs/utils");
const typedoc_1 = require("typedoc");
/**
 * @category Member Partials
 */
function member(model, options) {
    const md = [];
    if (this.options.getValue('useHTMLAnchors')) {
        md.push(`<a id="${model.anchor}" name="${model.anchor}"></a>`);
    }
    if (!model.hasOwnDocument && !(model.kind === typedoc_1.ReflectionKind.Constructor)) {
        md.push((0, markdown_1.heading)(options.headingLevel, this.partials.memberTitle(model)));
    }
    const getMember = (reflection) => {
        if ([
            typedoc_1.ReflectionKind.Class,
            typedoc_1.ReflectionKind.Interface,
            typedoc_1.ReflectionKind.Enum,
        ].includes(reflection.kind)) {
            return this.partials.memberWithGroups(reflection, {
                headingLevel: options.headingLevel + 1,
            });
        }
        if (reflection.kind === typedoc_1.ReflectionKind.Constructor) {
            return this.partials.constructor(reflection, {
                headingLevel: options.headingLevel,
            });
        }
        if (reflection.kind === typedoc_1.ReflectionKind.Accessor) {
            return this.partials.accessor(reflection, {
                headingLevel: options.headingLevel + 1,
            });
        }
        if (reflection.signatures) {
            return reflection.signatures
                ?.map((signature) => {
                const signatureMd = [];
                const multipleSignatures = reflection.signatures && reflection.signatures?.length > 1;
                if (multipleSignatures) {
                    signatureMd.push((0, markdown_1.heading)(options.headingLevel + 1, `${(0, utils_1.escapeChars)(signature.name)}(${signature.parameters
                        ?.map((param) => param.name)
                        .join(', ')})`));
                }
                signatureMd.push(this.partials.signature(signature, {
                    headingLevel: multipleSignatures
                        ? options.headingLevel + 2
                        : options.headingLevel + 1,
                    nested: options.nested,
                }));
                return signatureMd.join('\n\n');
            })
                .join('\n\n');
        }
        if (reflection instanceof typedoc_1.ReferenceReflection) {
            return this.partials.referenceMember(reflection);
        }
        return this.partials.declaration(reflection, {
            headingLevel: options.headingLevel + 1,
            nested: options.nested,
        });
    };
    const member = getMember(model);
    if (member) {
        md.push(member);
    }
    return md.join('\n\n');
}
exports.member = member;
