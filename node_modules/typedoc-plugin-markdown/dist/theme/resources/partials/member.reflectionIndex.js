"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reflectionIndex = void 0;
const markdown_1 = require("../../../libs/markdown");
const utils_1 = require("../../../libs/utils");
const text_mappings_1 = require("../../../options/text-mappings");
const typedoc_1 = require("typedoc");
/**
 * Renders the index section of a reflection.
 *
 * @category Member Partials
 */
function reflectionIndex(model, options) {
    const md = [];
    const getGroup = (group) => {
        if (this.options.getValue('indexFormat') === 'table') {
            return getTable(this, group.children);
        }
        return getList(this, group.children);
    };
    const subHeadingLevel = options.headingLevel;
    if (model.categories) {
        model.categories.forEach((categoryGroup) => {
            md.push((0, markdown_1.heading)(subHeadingLevel, categoryGroup.title) + '\n');
            if (categoryGroup.description) {
                md.push(this.partials.commentParts(categoryGroup.description) + '\n');
            }
            md.push(getGroup(categoryGroup) + '\n');
        });
    }
    else {
        const groups = model.groups?.filter((group) => group.allChildrenHaveOwnDocument());
        if (this.options.getValue('excludeGroups')) {
            const children = groups?.reduce((acc, group) => {
                return [...acc, ...group.children];
            }, []);
            if (this.options.getValue('indexFormat') === 'table') {
                md.push(getTable(this, children || []));
            }
            else {
                md.push(getList(this, children || []));
            }
        }
        else {
            groups?.forEach((reflectionGroup) => {
                if (reflectionGroup.categories) {
                    md.push((0, markdown_1.heading)(subHeadingLevel, reflectionGroup.title) + '\n');
                    reflectionGroup.categories.forEach((categoryGroup) => {
                        md.push((0, markdown_1.heading)(subHeadingLevel + 1, categoryGroup.title) + '\n');
                        if (categoryGroup.description) {
                            md.push(this.partials.commentParts(categoryGroup.description) + '\n');
                        }
                        md.push(getGroup(categoryGroup) + '\n');
                    });
                }
                else {
                    const kindKey = text_mappings_1.PLURAL_KIND_KEY_MAP[reflectionGroup.title];
                    md.push((0, markdown_1.heading)(subHeadingLevel, this.getText(kindKey) || reflectionGroup.title) + '\n');
                    md.push(getGroup(reflectionGroup) + '\n');
                }
            });
        }
    }
    return md.join('\n');
}
exports.reflectionIndex = reflectionIndex;
function getTable(context, children) {
    const headers = [
        context.options.getValue('excludeGroups')
            ? context.getText('label.member')
            : typedoc_1.ReflectionKind.singularString(children[0].kind),
        context.getText('label.description'),
    ];
    const rows = [];
    children.forEach((child) => {
        const row = [];
        if (child.url) {
            row.push((0, markdown_1.link)((0, utils_1.escapeChars)(child.name), context.getRelativeUrl(child.url)));
        }
        const comment = context.helpers.getDeclarationComment(child);
        if (comment?.summary?.length) {
            row.push((0, utils_1.getFirstParagrph)(context.partials.commentParts(comment.summary)));
        }
        else {
            row.push('-');
        }
        rows.push(row);
    });
    return (0, markdown_1.table)(headers, rows);
}
function getList(context, children) {
    const filteredChildren = children
        .filter((child) => Boolean(child.url))
        .map((child) => {
        const name = child.name === 'constructor'
            ? `${child.signatures
                ? child.signatures[0].name
                : context.getText('kind.constructor.singular')}`
            : child.name;
        return child.url
            ? `- ${(0, markdown_1.link)((0, utils_1.escapeChars)(name), context.getRelativeUrl(child.url))}`
            : '';
    });
    return filteredChildren.join('\n');
}
