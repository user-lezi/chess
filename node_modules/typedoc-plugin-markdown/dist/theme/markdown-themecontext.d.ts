import { MarkdownPageEvent } from '../app/events';
import { MarkdownRendererHooks } from '../app/renderer';
import { TextContentMappings } from '../options/index.js';
import { MarkdownTheme, PackageMetaData } from './index.js';
import { Options, Reflection } from 'typedoc';
/**
 * The theme context class that is provided as context on the rendering of every page.
 *
 * It is heavily influenced by the equivalent [DefaultThemeRenderContext](https://typedoc.org/api/classes/DefaultThemeRenderContext.html) from the default theme.
 *
 * This class can be used to customize the theme output by extending the class and overriding the [templates](#templates), [partials](#partials) and [helpers](#helpers).
 *
 * @usage
 *
 * ```ts
 * class MyMarkdownTheme extends MarkdownTheme {
 *   getRenderContext(page) {
 *     return new MyMarkdownThemeContext(this, page, this.application.options);
 *   }
 * }
 * ```
 *
 * @groupDescription Properties
 *
 * Properties are passed into the constructor and are used to provide context to the theme.
 *
 * @groupDescription Methods
 *
 * General context aware helper methods not bound to any specific models that can be used by the theme resources.
 *
 * @groupDescription Resources
 *
 * Theme resources are the main building blocks for the theme context. They are split into three namespaces: `templates`, `partials` and `helpers`.
 *
 * @privateRemarks
 *
 * In order to create cleaner code, internally individual templates located in the `resources/templates` directory are bound to the this.
 *
 * @category Theme
 */
export declare class MarkdownThemeContext {
    /**
     * The theme instance.
     */
    private theme;
    /**
     * The current page event.
     */
    readonly page: MarkdownPageEvent<Reflection>;
    /**
     * The options provided to the application.
     */
    readonly options: Options;
    /**
     *
     */
    constructor(
    /**
     * The theme instance.
     */
    theme: MarkdownTheme, 
    /**
     * The current page event.
     */
    page: MarkdownPageEvent<Reflection>, 
    /**
     * The options provided to the application.
     */
    options: Options);
    /**
     * Holds the textmappings object of the theme.
     */
    private textContentMappings;
    /**
     * Holds meta data for individual packages (if entryPointStrategy equals `packages`).
     *
     * This is required for generating package specific documentation.
     */
    private packagesMetaData;
    /**
     * Then `templates` namespace holds the main templates for the theme and are mapped to single pages and configured in the MarkdownTheme.
     *
     * All templates return a string that is passed back to the renderer. Internally templates call partials and helpers.
     *
     * @group Resources
     */
    templates: {
        project: () => string;
        readme: () => string;
        reflection: () => string;
    };
    /**
     * The `partials` namespace holds the partials for the theme and are used by templates to map speficic models to page output.
     *
     * Please note that partials::
     *
     * - Take a `model` param (that references a specific TypeDoc model) and an `options` param if required.
     * - Can call other partials and helpers.
     * - Must return a string.
     *
     * Partials are categorised by their use:
     *
     * - [Page Partials](#page-partials): Partials that render core page elements such as header and breadcrumbs.
     * - [Container Partials](#container-partials): Partials that are used to render reflection groups and categories.
     * - [Member Partials](#member-partials): Partials that render specific parts of reflections.
     * - [Comment Partials](#comment-partials): Partials that render comments.
     * - [Type Partials](#type-partials): Partials that render specific TypeDoc model types.
     *
     * @group Resources
     */
    partials: {
        comment: (model: import("typedoc").Comment, options?: {
            headingLevel?: number | undefined;
            showSummary?: boolean | undefined;
            showTags?: boolean | undefined;
            isTableColumn?: boolean | undefined;
        }) => string;
        commentParts: (model: import("typedoc").CommentDisplayPart[]) => string;
        body: (model: import("typedoc").ContainerReflection, options: {
            headingLevel: number;
        }) => string;
        categories: (model: import("typedoc").ReflectionCategory[], options: {
            headingLevel: number;
        }) => string;
        groups: (model: import("typedoc").ReflectionGroup[], options: {
            headingLevel: number;
        }) => string;
        members: (model: import("typedoc").DeclarationReflection[], options: {
            headingLevel: number;
        }) => string;
        accessor: (model: import("typedoc").DeclarationReflection, options: {
            headingLevel: number;
        }) => string;
        constructor: (model: import("typedoc").DeclarationReflection, options: {
            headingLevel: number;
        }) => string;
        declaration: (model: import("typedoc").DeclarationReflection, options?: {
            headingLevel: number;
            nested?: boolean | undefined;
        }) => string;
        declarationTitle: (model: import("typedoc").DeclarationReflection) => string;
        enumMembersTable: (model: import("typedoc").DeclarationReflection[]) => string;
        hierarchy: (model: import("typedoc").DeclarationHierarchy, options: {
            headingLevel: number;
        }) => string;
        indexSignature: (model: import("typedoc").SignatureReflection) => string;
        inheritance: (model: import("typedoc").DeclarationReflection | import("typedoc").SignatureReflection, options: {
            headingLevel: number;
        }) => string;
        memberTitle: (model: import("typedoc").DeclarationReflection) => string;
        memberWithGroups: (model: import("typedoc").DeclarationReflection, options: {
            headingLevel: number;
        }) => string;
        parametersList: (model: import("typedoc").ParameterReflection[]) => string;
        parametersTable: (model: import("typedoc").ParameterReflection[]) => string;
        declarationsTable: (model: import("typedoc").DeclarationReflection[], options?: {
            isEventProps: boolean;
        } | undefined) => string;
        referenceMember: (model: import("typedoc").ReferenceReflection) => string;
        reflectionFlags: (model: Reflection) => string;
        reflectionIndex: (model: import("typedoc").DeclarationReflection | import("typedoc").ProjectReflection, options: {
            headingLevel: number;
        }) => string;
        signature: (model: import("typedoc").SignatureReflection, options: {
            headingLevel: number;
            nested?: boolean | undefined;
            accessor?: string | undefined;
        }) => string;
        signatureParameters: (model: import("typedoc").ParameterReflection[]) => string;
        signatureReturns: (model: import("typedoc").SignatureReflection, options: {
            headingLevel: number;
        }) => string;
        signatureTitle: (model: import("typedoc").SignatureReflection, options?: {
            accessor?: string | undefined;
            includeType?: boolean | undefined;
        } | undefined) => string;
        sources: (model: import("typedoc").DeclarationReflection | import("typedoc").SignatureReflection, options: {
            headingLevel: number;
        }) => string;
        member: (model: import("typedoc").DeclarationReflection, options: {
            headingLevel: number;
            nested?: boolean | undefined;
        }) => string;
        typeAndParent: (model: import("typedoc").ReferenceType | import("typedoc").ArrayType) => string;
        typeArguments: (model: import("typedoc").SomeType[], options?: {
            foreCollpase?: boolean | undefined;
        } | undefined) => string;
        typeDeclaration: (model: import("typedoc").DeclarationReflection[], options: {
            headingLevel: number;
        }) => string;
        typeDeclarationList: (model: import("typedoc").DeclarationReflection[], headingLevel: number) => string;
        typeDeclarationTable: (model: import("typedoc").DeclarationReflection[]) => string;
        typeParametersList: (model: import("typedoc").TypeParameterReflection[]) => string;
        typeParametersTable: (model: import("typedoc").TypeParameterReflection[]) => string;
        breadcrumbs: () => string;
        footer: () => string;
        header: () => string;
        packagesIndex: (model: import("typedoc").ProjectReflection) => string;
        pageTitle: () => string;
        arrayType: (model: import("typedoc").ArrayType) => string;
        conditionalType: (model: import("typedoc").ConditionalType) => string;
        indexAccessType: (model: import("typedoc").IndexedAccessType) => string;
        inferredType: (model: import("typedoc").InferredType) => string;
        intersectionType: (model: import("typedoc").IntersectionType) => string;
        intrinsicType: (model: import("typedoc").IntrinsicType) => string;
        literalType: (model: import("typedoc").LiteralType) => string;
        namedTupleType: (model: import("typedoc").NamedTupleMember) => string;
        queryType: (model: import("typedoc").QueryType) => string;
        referenceType: (model: import("typedoc").ReferenceType) => string;
        declarationType: (model: import("typedoc").DeclarationReflection) => string;
        functionType: (model: import("typedoc").SignatureReflection[], options?: {
            forceParameterType: boolean;
        } | undefined) => string;
        reflectionType: (model: import("typedoc").ReflectionType, options?: {
            foreCollpase?: boolean | undefined;
        } | undefined) => string;
        someType: (model?: import("typedoc").SomeType | undefined) => string;
        tupleType: (model: import("typedoc").TupleType) => string;
        typeOperatorType: (model: import("typedoc").TypeOperatorType) => string;
        unionType: (model: import("typedoc").UnionType) => string;
        unknownType: (model: import("typedoc").UnknownType) => string;
    };
    /**
     * The `helpers` namespace holds the helpers for the theme and are smaller utility functions that return snippets or text or other data transformations.
     *
     * Please note that partials:
     *
     * - Take a `model` param (that references a specific TypeDoc model) and an `options` param if required.
     * - Can reference other helpers but should not reference partials.
     * - Can return strings or other models.
     *
     * @group Resources
     */
    helpers: {
        getDeclarationComment: (model: import("typedoc").DeclarationReflection) => any;
        getDeclarationType: (model: import("typedoc").DeclarationReflection) => import("typedoc").SomeType | undefined;
        getFlattenedDeclarations: (model: import("typedoc").DeclarationReflection[], options?: {
            includeSignatures: boolean;
        } | undefined) => import("typedoc").DeclarationReflection[];
        getHierarchyType: (model: import("typedoc").SomeType, options?: {
            isTarget: boolean;
        } | undefined) => string;
        getKeyword: (model: import("typedoc").ReflectionKind) => string;
        getModifier: (model: import("typedoc").DeclarationReflection) => string | null;
        getParameterDefaultValue: (model: import("typedoc").ParameterReflection) => string;
        getPropertyDefaultValue: (model: import("typedoc").DeclarationReflection) => string | null;
        getReturnType: (model?: import("typedoc").SomeType | undefined) => string;
        isGroupKind: (model: import("typedoc").DeclarationReflection | import("typedoc").SignatureReflection) => boolean;
    };
    /**
     * Get text mappings from the theme.
     *
     * @param key - The key of the text mappings
     */
    getText(key: keyof TextContentMappings): string;
    /**
     * Returns the package meta data for a given package name when entrypointStrategy is set to `packages`.
     *
     * @param packageName - The package name as per `name` field from `package.json`.
     */
    getPackageMetaData(packageName: string): PackageMetaData;
    /**
     * Returns the relative URL (from the current page context url).
     *
     * If public path is set, it will be used as the base URL.
     *
     * @param url - The URL to make relative.
     * @param ignorePublicPath - Whether to ignore the public path.
     */
    getRelativeUrl(url: string, ignorePublicPath?: boolean): string;
    /**
     * Hook into the TypeDoc rendering system.
     *
     * @internal
     */
    hook: (name: keyof MarkdownRendererHooks) => string[];
}
